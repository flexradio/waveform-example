<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSDR Waveform SDK: include/waveform_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SmartSDR Waveform SDK<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">waveform_api.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Public definitions of waveform library functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;netinet/in.h&gt;</code><br />
<code>#include &lt;sys/time.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
</div>
<p><a href="waveform__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwaveform__meter__entry.html">waveform_meter_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to hold a description of a meter.  <a href="structwaveform__meter__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2950e21aa7ceef26c56148bbf1f6b82c" id="r_a2950e21aa7ceef26c56148bbf1f6b82c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2950e21aa7ceef26c56148bbf1f6b82c">waveform_send_api_command</a>(waveform,  command, ...)</td></tr>
<tr class="memdesc:a2950e21aa7ceef26c56148bbf1f6b82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a command to the radio.  <br /></td></tr>
<tr class="separator:a2950e21aa7ceef26c56148bbf1f6b82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d937cadd66372415110ad0b8a006b4a" id="r_a7d937cadd66372415110ad0b8a006b4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d937cadd66372415110ad0b8a006b4a">waveform_send_timed_api_command</a>(waveform,  at,  command, ...)&#160;&#160;&#160;   <a class="el" href="#a223d94c4c088c85efaba9732fd2ca4dc">waveform_send_timed_api_command_cb</a>(waveform, at, NULL, NULL, NULL, command##__VA_ARGS__)</td></tr>
<tr class="memdesc:a7d937cadd66372415110ad0b8a006b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a command to the radio at a specified time.  <br /></td></tr>
<tr class="separator:a7d937cadd66372415110ad0b8a006b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac00b936a46820045bed3acebf0957fe8" id="r_ac00b936a46820045bed3acebf0957fe8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac00b936a46820045bed3acebf0957fe8">waveform_state_cb_t</a>) (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, enum <a class="el" href="#ae2459fae8ab0eac5ec65fac9439ac7f0">waveform_state</a> state, void *arg)</td></tr>
<tr class="memdesc:ac00b936a46820045bed3acebf0957fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the waveform state changes.  <br /></td></tr>
<tr class="separator:ac00b936a46820045bed3acebf0957fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30844370d08fd6482019736b1c7de4cd" id="r_a30844370d08fd6482019736b1c7de4cd"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30844370d08fd6482019736b1c7de4cd">waveform_cmd_cb_t</a>) (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, unsigned int argc, char *argv[], void *arg)</td></tr>
<tr class="memdesc:a30844370d08fd6482019736b1c7de4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a command is requested.  <br /></td></tr>
<tr class="separator:a30844370d08fd6482019736b1c7de4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c3b1bbb04e6d6bfe4a904a1d8599f2" id="r_a81c3b1bbb04e6d6bfe4a904a1d8599f2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81c3b1bbb04e6d6bfe4a904a1d8599f2">waveform_data_cb_t</a>) (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, struct waveform_vita_packet *packet, size_t packet_size, void *arg)</td></tr>
<tr class="memdesc:a81c3b1bbb04e6d6bfe4a904a1d8599f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when data is ready for the waveform.  <br /></td></tr>
<tr class="separator:a81c3b1bbb04e6d6bfe4a904a1d8599f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab806b6ea2fbe7dc77fa48faa13ded221" id="r_ab806b6ea2fbe7dc77fa48faa13ded221"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab806b6ea2fbe7dc77fa48faa13ded221">waveform_response_cb_t</a>) (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, unsigned int code, const char *message, void *arg)</td></tr>
<tr class="memdesc:ab806b6ea2fbe7dc77fa48faa13ded221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a response to a waveform command is received.  <br /></td></tr>
<tr class="separator:ab806b6ea2fbe7dc77fa48faa13ded221"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1607bb449bae065c8f53b00d9ad5e9af" id="r_a1607bb449bae065c8f53b00d9ad5e9af"><td class="memItemLeft" align="right" valign="top"><a id="a1607bb449bae065c8f53b00d9ad5e9af" name="a1607bb449bae065c8f53b00d9ad5e9af"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1607bb449bae065c8f53b00d9ad5e9af">waveform_units</a> { <br />
&#160;&#160;<b>DB</b>
, <b>DBM</b>
, <b>DBFS</b>
, <b>VOLTS</b>
, <br />
&#160;&#160;<b>AMPS</b>
, <b>RPM</b>
, <b>TEMP_F</b>
, <b>TEMP_C</b>
, <br />
&#160;&#160;<b>SWR</b>
, <b>WATTS</b>
, <b>PERCENT</b>
, <b>NONE</b>
<br />
 }</td></tr>
<tr class="memdesc:a1607bb449bae065c8f53b00d9ad5e9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for waveform meter units. <br /></td></tr>
<tr class="separator:a1607bb449bae065c8f53b00d9ad5e9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2459fae8ab0eac5ec65fac9439ac7f0" id="r_ae2459fae8ab0eac5ec65fac9439ac7f0"><td class="memItemLeft" align="right" valign="top"><a id="ae2459fae8ab0eac5ec65fac9439ac7f0" name="ae2459fae8ab0eac5ec65fac9439ac7f0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2459fae8ab0eac5ec65fac9439ac7f0">waveform_state</a> { <b>ACTIVE</b>
, <b>INACTIVE</b>
, <b>PTT_REQUESTED</b>
, <b>UNKEY_REQUESTED</b>
 }</td></tr>
<tr class="memdesc:ae2459fae8ab0eac5ec65fac9439ac7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible states passed to a state callback waveform_state_cb_t. <br /></td></tr>
<tr class="separator:ae2459fae8ab0eac5ec65fac9439ac7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4c553be06c514186a53441a646a371" id="r_a0d4c553be06c514186a53441a646a371"><td class="memItemLeft" align="right" valign="top"><a id="a0d4c553be06c514186a53441a646a371" name="a0d4c553be06c514186a53441a646a371"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d4c553be06c514186a53441a646a371">waveform_packet_type</a> { <b>SPEAKER_DATA</b>
, <b>TRANSMITTER_DATA</b>
 }</td></tr>
<tr class="memdesc:a0d4c553be06c514186a53441a646a371"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of packet to send to the radio, either to the speaker or the transmitter. <br /></td></tr>
<tr class="separator:a0d4c553be06c514186a53441a646a371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48fc5c972fcaafee3a74e6095e7eac0" id="r_af48fc5c972fcaafee3a74e6095e7eac0"><td class="memItemLeft" align="right" valign="top"><a id="af48fc5c972fcaafee3a74e6095e7eac0" name="af48fc5c972fcaafee3a74e6095e7eac0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af48fc5c972fcaafee3a74e6095e7eac0">waveform_log_levels</a> { <br />
&#160;&#160;<b>WF_LOG_TRACE</b> = 100
, <b>WF_LOG_DEBUG</b> = 200
, <b>WF_LOG_INFO</b> = 300
, <b>WF_LOG_WARNING</b> = 400
, <br />
&#160;&#160;<b>WF_LOG_ERROR</b> = 500
, <b>WF_LOG_SEVERE</b> = 600
, <b>WF_LOG_FATAL</b> = 700
<br />
 }</td></tr>
<tr class="memdesc:af48fc5c972fcaafee3a74e6095e7eac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The levels for log messages. Higher is more severe. <br /></td></tr>
<tr class="separator:af48fc5c972fcaafee3a74e6095e7eac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bfb63574043888d9cd0d4156f997ac" id="r_ac1bfb63574043888d9cd0d4156f997ac"><td class="memItemLeft" align="right" valign="top"><a id="ac1bfb63574043888d9cd0d4156f997ac" name="ac1bfb63574043888d9cd0d4156f997ac"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1bfb63574043888d9cd0d4156f997ac">waveform_sample_rate</a> { <br />
&#160;&#160;<b>SR_3K</b> = 0x00
, <b>SR_6K</b> = 0x01
, <b>SR_12K</b> = 0x02
, <b>SR_24K</b> = 0x03
, <br />
&#160;&#160;<b>SR_48K</b> = 0x04
, <b>SR_96K</b> = 0x05
, <b>SR_192K</b> = 0x06
, <b>SR_384K</b> = 0x07
, <br />
&#160;&#160;<b>SR_768K</b> = 0x08
, <b>SR_1568K</b> = 0x09
, <b>SR_3072K</b> = 0x0A
, <b>SR_6144K</b> = 0x0B
, <br />
&#160;&#160;<b>SR_12288K</b> = 0x0C
, <b>SR_24576K</b> = 0x0D
, <b>SR_49152K</b> = 0x0E
, <b>SR_98304K</b> = 0x0F
, <br />
&#160;&#160;<b>SR_4K</b> = 0x10
, <b>SR_8K</b> = 0x11
, <b>SR_16K</b> = 0x12
, <b>SR_32K</b> = 0x13
, <br />
&#160;&#160;<b>SR_64K</b> = 0x14
, <b>SR_128K</b> = 0x15
, <b>SR_256K</b> = 0x16
, <b>SR_512K</b> = 0x17
, <br />
&#160;&#160;<b>SR_1024K</b> = 0x18
, <b>SR_2048K</b> = 0x19
, <b>SR_4096K</b> = 0x1A
, <b>SR_8192K</b> = 0x1B
, <br />
&#160;&#160;<b>SR_16384K</b> = 0x1C
, <b>SR_32768K</b> = 0x1D
, <b>SR_65536K</b> = 0x1E
, <b>SR_131072K</b> = 0x1F
<br />
 }</td></tr>
<tr class="memdesc:ac1bfb63574043888d9cd0d4156f997ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to hold the possible sample rates for waveform. <br /></td></tr>
<tr class="separator:ac1bfb63574043888d9cd0d4156f997ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7e7640dbd52b06d440a74f7d406d2b2b" id="r_a7e7640dbd52b06d440a74f7d406d2b2b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b">waveform_create</a> (struct radio_t *radio, const char *name, const char *short_name, const char *underlying_mode, const char *version, enum <a class="el" href="#ac1bfb63574043888d9cd0d4156f997ac">waveform_sample_rate</a> data_sample_rate)</td></tr>
<tr class="memdesc:a7e7640dbd52b06d440a74f7d406d2b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a waveform.  <br /></td></tr>
<tr class="separator:a7e7640dbd52b06d440a74f7d406d2b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548cfeaa2b9392f547c3d0aa2bcebff7" id="r_a548cfeaa2b9392f547c3d0aa2bcebff7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a548cfeaa2b9392f547c3d0aa2bcebff7">waveform_destroy</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform)</td></tr>
<tr class="memdesc:a548cfeaa2b9392f547c3d0aa2bcebff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a waveform.  <br /></td></tr>
<tr class="separator:a548cfeaa2b9392f547c3d0aa2bcebff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cf19d09e17739401827be212740596" id="r_a92cf19d09e17739401827be212740596"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92cf19d09e17739401827be212740596">waveform_register_state_cb</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, <a class="el" href="#ac00b936a46820045bed3acebf0957fe8">waveform_state_cb_t</a> cb, void *arg)</td></tr>
<tr class="memdesc:a92cf19d09e17739401827be212740596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a stauts change callback for a waveform.  <br /></td></tr>
<tr class="separator:a92cf19d09e17739401827be212740596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e6660970f108f0c7077fecce516ab9" id="r_af8e6660970f108f0c7077fecce516ab9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8e6660970f108f0c7077fecce516ab9">waveform_register_tx_data_cb</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, <a class="el" href="#a81c3b1bbb04e6d6bfe4a904a1d8599f2">waveform_data_cb_t</a> cb, void *arg)</td></tr>
<tr class="memdesc:af8e6660970f108f0c7077fecce516ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a transmitter data callback for a waveform.  <br /></td></tr>
<tr class="separator:af8e6660970f108f0c7077fecce516ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40d17a9d9365e2586d2a347ec89bb14" id="r_aa40d17a9d9365e2586d2a347ec89bb14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa40d17a9d9365e2586d2a347ec89bb14">waveform_register_rx_data_cb</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, <a class="el" href="#a81c3b1bbb04e6d6bfe4a904a1d8599f2">waveform_data_cb_t</a> cb, void *arg)</td></tr>
<tr class="memdesc:aa40d17a9d9365e2586d2a347ec89bb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a receive data callback for a waveform.  <br /></td></tr>
<tr class="separator:aa40d17a9d9365e2586d2a347ec89bb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6d1786f6bc57dd7eb37d8f5d0458e2" id="r_a9b6d1786f6bc57dd7eb37d8f5d0458e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b6d1786f6bc57dd7eb37d8f5d0458e2">waveform_register_unknown_data_cb</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, <a class="el" href="#a81c3b1bbb04e6d6bfe4a904a1d8599f2">waveform_data_cb_t</a> cb, void *arg)</td></tr>
<tr class="memdesc:a9b6d1786f6bc57dd7eb37d8f5d0458e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a unknown data packet callback for a waveform.  <br /></td></tr>
<tr class="separator:a9b6d1786f6bc57dd7eb37d8f5d0458e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85463b94e6ff92583bdb5e74e9dfbb2d" id="r_a85463b94e6ff92583bdb5e74e9dfbb2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85463b94e6ff92583bdb5e74e9dfbb2d">waveform_register_byte_data_cb</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, <a class="el" href="#a81c3b1bbb04e6d6bfe4a904a1d8599f2">waveform_data_cb_t</a> cb, void *arg)</td></tr>
<tr class="memdesc:a85463b94e6ff92583bdb5e74e9dfbb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a raw byte data packet callback for a waveform.  <br /></td></tr>
<tr class="separator:a85463b94e6ff92583bdb5e74e9dfbb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d28505507751b3710d6fdcb5a844fd" id="r_a48d28505507751b3710d6fdcb5a844fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48d28505507751b3710d6fdcb5a844fd">waveform_register_status_cb</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, const char *status_name, <a class="el" href="#a30844370d08fd6482019736b1c7de4cd">waveform_cmd_cb_t</a> cb, void *arg)</td></tr>
<tr class="memdesc:a48d28505507751b3710d6fdcb5a844fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a status callback.  <br /></td></tr>
<tr class="separator:a48d28505507751b3710d6fdcb5a844fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad145a05cea374bd25e652b91f31c311c" id="r_ad145a05cea374bd25e652b91f31c311c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad145a05cea374bd25e652b91f31c311c">waveform_register_command_cb</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, const char *command_name, <a class="el" href="#a30844370d08fd6482019736b1c7de4cd">waveform_cmd_cb_t</a> cb, void *arg)</td></tr>
<tr class="memdesc:ad145a05cea374bd25e652b91f31c311c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a command callback.  <br /></td></tr>
<tr class="separator:ad145a05cea374bd25e652b91f31c311c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39cf0e0b1aa16e00ecf23141a0a231e" id="r_af39cf0e0b1aa16e00ecf23141a0a231e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af39cf0e0b1aa16e00ecf23141a0a231e">waveform_send_api_command_cb</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, <a class="el" href="#ab806b6ea2fbe7dc77fa48faa13ded221">waveform_response_cb_t</a> cb, void *arg, const char *command,...)</td></tr>
<tr class="memdesc:af39cf0e0b1aa16e00ecf23141a0a231e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a command to the radio and invokes callback.  <br /></td></tr>
<tr class="separator:af39cf0e0b1aa16e00ecf23141a0a231e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223d94c4c088c85efaba9732fd2ca4dc" id="r_a223d94c4c088c85efaba9732fd2ca4dc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a223d94c4c088c85efaba9732fd2ca4dc">waveform_send_timed_api_command_cb</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, const struct timespec *at, <a class="el" href="#ab806b6ea2fbe7dc77fa48faa13ded221">waveform_response_cb_t</a> complete_cb, <a class="el" href="#ab806b6ea2fbe7dc77fa48faa13ded221">waveform_response_cb_t</a> queued_cb, void *arg, const char *command,...)</td></tr>
<tr class="memdesc:a223d94c4c088c85efaba9732fd2ca4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a timed command to the radio and invokes callbacks.  <br /></td></tr>
<tr class="separator:a223d94c4c088c85efaba9732fd2ca4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614e0ea5956c33b17d1c6b673a8fb12b" id="r_a614e0ea5956c33b17d1c6b673a8fb12b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a614e0ea5956c33b17d1c6b673a8fb12b">waveform_register_meter</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, const char *name, float min, float max, enum <a class="el" href="#a1607bb449bae065c8f53b00d9ad5e9af">waveform_units</a> unit)</td></tr>
<tr class="memdesc:a614e0ea5956c33b17d1c6b673a8fb12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new meter to a meter list.  <br /></td></tr>
<tr class="separator:a614e0ea5956c33b17d1c6b673a8fb12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92578b1a0afffc97c43b4b64c785e090" id="r_a92578b1a0afffc97c43b4b64c785e090"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92578b1a0afffc97c43b4b64c785e090">waveform_meter_set_float_value</a> (const struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, char *name, float value)</td></tr>
<tr class="memdesc:a92578b1a0afffc97c43b4b64c785e090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a meter given the name.  <br /></td></tr>
<tr class="separator:a92578b1a0afffc97c43b4b64c785e090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc87c7c72f6a7849fe357827bdcfc13" id="r_abfc87c7c72f6a7849fe357827bdcfc13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfc87c7c72f6a7849fe357827bdcfc13">waveform_meter_set_int_value</a> (const struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, char *name, short value)</td></tr>
<tr class="memdesc:abfc87c7c72f6a7849fe357827bdcfc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a meter given the name.  <br /></td></tr>
<tr class="separator:abfc87c7c72f6a7849fe357827bdcfc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dfbbe31f9eba594d4b91e7d858ef90" id="r_a53dfbbe31f9eba594d4b91e7d858ef90"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53dfbbe31f9eba594d4b91e7d858ef90">waveform_meters_send</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform)</td></tr>
<tr class="memdesc:a53dfbbe31f9eba594d4b91e7d858ef90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a meter list to the radio.  <br /></td></tr>
<tr class="separator:a53dfbbe31f9eba594d4b91e7d858ef90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cd1dcf1f5d9f48369b5e8a3c5b9c8a" id="r_a69cd1dcf1f5d9f48369b5e8a3c5b9c8a"><td class="memItemLeft" align="right" valign="top">struct radio_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69cd1dcf1f5d9f48369b5e8a3c5b9c8a">waveform_radio_create</a> (const struct sockaddr_in *addr)</td></tr>
<tr class="memdesc:a69cd1dcf1f5d9f48369b5e8a3c5b9c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a radio definition.  <br /></td></tr>
<tr class="separator:a69cd1dcf1f5d9f48369b5e8a3c5b9c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3b4c24c78713e599c422575c8681e0" id="r_a8e3b4c24c78713e599c422575c8681e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e3b4c24c78713e599c422575c8681e0">waveform_radio_destroy</a> (struct radio_t *radio)</td></tr>
<tr class="memdesc:a8e3b4c24c78713e599c422575c8681e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a radio.  <br /></td></tr>
<tr class="separator:a8e3b4c24c78713e599c422575c8681e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf3e4737aaceab800d7dc193ca5c603" id="r_adbf3e4737aaceab800d7dc193ca5c603"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbf3e4737aaceab800d7dc193ca5c603">waveform_radio_wait</a> (const struct radio_t *radio)</td></tr>
<tr class="memdesc:adbf3e4737aaceab800d7dc193ca5c603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the radio processing to complete.  <br /></td></tr>
<tr class="separator:adbf3e4737aaceab800d7dc193ca5c603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e070d291054bfac3961ca172d8e77a" id="r_a35e070d291054bfac3961ca172d8e77a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35e070d291054bfac3961ca172d8e77a">waveform_radio_start</a> (struct radio_t *radio)</td></tr>
<tr class="memdesc:a35e070d291054bfac3961ca172d8e77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the radio.  <br /></td></tr>
<tr class="separator:a35e070d291054bfac3961ca172d8e77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ec4ad3e11ef29156d65ad86f50d6ee" id="r_a62ec4ad3e11ef29156d65ad86f50d6ee"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62ec4ad3e11ef29156d65ad86f50d6ee">waveform_send_data_packet</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, float *samples, size_t num_samples, enum <a class="el" href="#a0d4c553be06c514186a53441a646a371">waveform_packet_type</a> type)</td></tr>
<tr class="memdesc:a62ec4ad3e11ef29156d65ad86f50d6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a data packet to the radio.  <br /></td></tr>
<tr class="separator:a62ec4ad3e11ef29156d65ad86f50d6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41645619373312c4f6a63059ef724cbc" id="r_a41645619373312c4f6a63059ef724cbc"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41645619373312c4f6a63059ef724cbc">waveform_send_byte_data_packet</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:a41645619373312c4f6a63059ef724cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a raw byte data packet to the radio.  <br /></td></tr>
<tr class="separator:a41645619373312c4f6a63059ef724cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58b7edbab25734d6f30fb2b3ded015d" id="r_af58b7edbab25734d6f30fb2b3ded015d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af58b7edbab25734d6f30fb2b3ded015d">get_packet_len</a> (const struct waveform_vita_packet *packet)</td></tr>
<tr class="memdesc:af58b7edbab25734d6f30fb2b3ded015d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a received packet.  <br /></td></tr>
<tr class="separator:af58b7edbab25734d6f30fb2b3ded015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6773dcf4ec0414dd390ac3f04c04e3a3" id="r_a6773dcf4ec0414dd390ac3f04c04e3a3"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6773dcf4ec0414dd390ac3f04c04e3a3">get_packet_data</a> (const struct waveform_vita_packet *packet)</td></tr>
<tr class="memdesc:a6773dcf4ec0414dd390ac3f04c04e3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the packet data.  <br /></td></tr>
<tr class="separator:a6773dcf4ec0414dd390ac3f04c04e3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f8cc8b85b17b299531e4430132f57f" id="r_ad4f8cc8b85b17b299531e4430132f57f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4f8cc8b85b17b299531e4430132f57f">get_packet_ts_int</a> (const struct waveform_vita_packet *packet)</td></tr>
<tr class="memdesc:ad4f8cc8b85b17b299531e4430132f57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the integer timestamp from a received packet.  <br /></td></tr>
<tr class="separator:ad4f8cc8b85b17b299531e4430132f57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf05450681f759538b7aec3cea041a5f" id="r_aaf05450681f759538b7aec3cea041a5f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf05450681f759538b7aec3cea041a5f">get_packet_ts_frac</a> (const struct waveform_vita_packet *packet)</td></tr>
<tr class="memdesc:aaf05450681f759538b7aec3cea041a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fractional timestamp from a received packet.  <br /></td></tr>
<tr class="separator:aaf05450681f759538b7aec3cea041a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c2875ca76cf346551efbb04e6a2029" id="r_a29c2875ca76cf346551efbb04e6a2029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29c2875ca76cf346551efbb04e6a2029">get_packet_ts</a> (const struct waveform_vita_packet *packet, struct timespec *ts)</td></tr>
<tr class="memdesc:a29c2875ca76cf346551efbb04e6a2029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the timestamp from a received pakcet.  <br /></td></tr>
<tr class="separator:a29c2875ca76cf346551efbb04e6a2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64bed2653fe8413949e4036ae6d41ff" id="r_ad64bed2653fe8413949e4036ae6d41ff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad64bed2653fe8413949e4036ae6d41ff">get_stream_id</a> (const struct waveform_vita_packet *packet)</td></tr>
<tr class="memdesc:ad64bed2653fe8413949e4036ae6d41ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stream ID from a received packet.  <br /></td></tr>
<tr class="separator:ad64bed2653fe8413949e4036ae6d41ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d99889ade0c2592b685dc30a9da43a9" id="r_a2d99889ade0c2592b685dc30a9da43a9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d99889ade0c2592b685dc30a9da43a9">get_class_id</a> (const struct waveform_vita_packet *packet)</td></tr>
<tr class="memdesc:a2d99889ade0c2592b685dc30a9da43a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class ID from a received packet.  <br /></td></tr>
<tr class="separator:a2d99889ade0c2592b685dc30a9da43a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74454f0bb04541a9aae0d4706908c16e" id="r_a74454f0bb04541a9aae0d4706908c16e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74454f0bb04541a9aae0d4706908c16e">get_packet_count</a> (const struct waveform_vita_packet *packet)</td></tr>
<tr class="memdesc:a74454f0bb04541a9aae0d4706908c16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current packet count from a received packet.  <br /></td></tr>
<tr class="separator:a74454f0bb04541a9aae0d4706908c16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417c2357020deba99e97a860c9a021a1" id="r_a417c2357020deba99e97a860c9a021a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a417c2357020deba99e97a860c9a021a1">waveform_set_context</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *wf, void *ctx)</td></tr>
<tr class="memdesc:a417c2357020deba99e97a860c9a021a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a structure for waveform context.  <br /></td></tr>
<tr class="separator:a417c2357020deba99e97a860c9a021a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f5ca6bc442a603a381eed9d8750e01" id="r_aa6f5ca6bc442a603a381eed9d8750e01"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6f5ca6bc442a603a381eed9d8750e01">waveform_get_context</a> (const struct <a class="el" href="structwaveform__t.html">waveform_t</a> *wf)</td></tr>
<tr class="memdesc:aa6f5ca6bc442a603a381eed9d8750e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the waveform context.  <br /></td></tr>
<tr class="separator:aa6f5ca6bc442a603a381eed9d8750e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbada3add642a353a622b3f0e50f5623" id="r_acbada3add642a353a622b3f0e50f5623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbada3add642a353a622b3f0e50f5623">waveform_register_meter_list</a> (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *wf, const struct <a class="el" href="structwaveform__meter__entry.html">waveform_meter_entry</a> list[], int num_meters)</td></tr>
<tr class="memdesc:acbada3add642a353a622b3f0e50f5623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a set of meters.  <br /></td></tr>
<tr class="separator:acbada3add642a353a622b3f0e50f5623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bf7d6b2413a5699718de606568852e" id="r_a63bf7d6b2413a5699718de606568852e"><td class="memItemLeft" align="right" valign="top">struct sockaddr_in *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63bf7d6b2413a5699718de606568852e">waveform_discover_radio</a> (const struct timeval *timeout)</td></tr>
<tr class="memdesc:a63bf7d6b2413a5699718de606568852e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a radio on the network.  <br /></td></tr>
<tr class="separator:a63bf7d6b2413a5699718de606568852e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5020177b871217781f1afe9e0cec790d" id="r_a5020177b871217781f1afe9e0cec790d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5020177b871217781f1afe9e0cec790d">waveform_set_log_level</a> (enum <a class="el" href="#af48fc5c972fcaafee3a74e6095e7eac0">waveform_log_levels</a> level)</td></tr>
<tr class="memdesc:a5020177b871217781f1afe9e0cec790d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the log verbosity of the library.  <br /></td></tr>
<tr class="separator:a5020177b871217781f1afe9e0cec790d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa580210dd0ffefbfdcad18d749250c" id="r_adfa580210dd0ffefbfdcad18d749250c"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfa580210dd0ffefbfdcad18d749250c">get_packet_byte_data</a> (const struct waveform_vita_packet *packet)</td></tr>
<tr class="memdesc:adfa580210dd0ffefbfdcad18d749250c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data portion of a raw byte data packet.  <br /></td></tr>
<tr class="separator:adfa580210dd0ffefbfdcad18d749250c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9834d4683d44948974fc305793e2dc13" id="r_a9834d4683d44948974fc305793e2dc13"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9834d4683d44948974fc305793e2dc13">get_packet_byte_data_length</a> (const struct waveform_vita_packet *packet)</td></tr>
<tr class="memdesc:a9834d4683d44948974fc305793e2dc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the raw byte data of a packet.  <br /></td></tr>
<tr class="separator:a9834d4683d44948974fc305793e2dc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public definitions of waveform library functions. </p>
<dl class="section author"><dt>Authors</dt><dd>Annaliese McDermond <a href="#" onclick="location.href='mai'+'lto:'+'ann'+'a@'+'fle'+'x-'+'rad'+'io'+'.co'+'m'; return false;">anna@<span class="obfuscator">.nosp@m.</span>flex<span class="obfuscator">.nosp@m.</span>-radi<span class="obfuscator">.nosp@m.</span>o.co<span class="obfuscator">.nosp@m.</span>m</a></dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2020 FlexRadio Systems</dd></dl>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, version 3.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2950e21aa7ceef26c56148bbf1f6b82c" name="a2950e21aa7ceef26c56148bbf1f6b82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2950e21aa7ceef26c56148bbf1f6b82c">&#9670;&#160;</a></span>waveform_send_api_command</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define waveform_send_api_command</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">waveform, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">command, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">   <a class="code hl_function" href="#af39cf0e0b1aa16e00ecf23141a0a231e">waveform_send_api_command_cb</a>(waveform, NULL, NULL, command, \</div>
<div class="line">                                ##__VA_ARGS__)</div>
<div class="ttc" id="awaveform__api_8h_html_af39cf0e0b1aa16e00ecf23141a0a231e"><div class="ttname"><a href="#af39cf0e0b1aa16e00ecf23141a0a231e">waveform_send_api_command_cb</a></div><div class="ttdeci">int32_t waveform_send_api_command_cb(struct waveform_t *waveform, waveform_response_cb_t cb, void *arg, const char *command,...)</div><div class="ttdoc">Sends a command to the radio and invokes callback.</div></div>
</div><!-- fragment -->
<p>Sends a command to the radio. </p>
<p>Does not wait for a response from the radio. This is a shortcut for passing NULL to the cb parameter of send_api_command_cb() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">command</td><td>A format string in printf(3) format. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments for format specification </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sequence number on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="a7d937cadd66372415110ad0b8a006b4a" name="a7d937cadd66372415110ad0b8a006b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d937cadd66372415110ad0b8a006b4a">&#9670;&#160;</a></span>waveform_send_timed_api_command</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define waveform_send_timed_api_command</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">waveform, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">at, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">command, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)&#160;&#160;&#160;   <a class="el" href="#a223d94c4c088c85efaba9732fd2ca4dc">waveform_send_timed_api_command_cb</a>(waveform, at, NULL, NULL, NULL, command##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a command to the radio at a specified time. </p>
<p>Does not wait for a response from the radio. This is a shortcut for passing NULL to the callback parameters of send_timed_api_command_cb() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">at</td><td>The time in the future in which to execute the commamnd </td></tr>
    <tr><td class="paramname">command</td><td>A format string in printf(3) format. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments for format specification </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sequence number on success or -1 on failure. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a30844370d08fd6482019736b1c7de4cd" name="a30844370d08fd6482019736b1c7de4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30844370d08fd6482019736b1c7de4cd">&#9670;&#160;</a></span>waveform_cmd_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* waveform_cmd_cb_t) (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, unsigned int argc, char *argv[], void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a command is requested. </p>
<p>when a command is requested from the client, this callback is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform the command was given to </td></tr>
    <tr><td class="paramname">argc</td><td>The number of arguments to the command </td></tr>
    <tr><td class="paramname">argv</td><td>The arguments to the command. </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument passed to waveform_register_command() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81c3b1bbb04e6d6bfe4a904a1d8599f2" name="a81c3b1bbb04e6d6bfe4a904a1d8599f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c3b1bbb04e6d6bfe4a904a1d8599f2">&#9670;&#160;</a></span>waveform_data_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* waveform_data_cb_t) (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, struct waveform_vita_packet *packet, size_t packet_size, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when data is ready for the waveform. </p>
<p>When new data arrives for the waveform, this callback is called. It is recommended that you create a buffer system to get the data off of this thread as quickly as possible and do your processing in a separate thread. Be efficient about this function as it will be called thousands of times a second when the waveform is active. Samples are returned as 32-bit floats in host byte order. They are in pairs, either Left first and Right second or I first and Q second depending on the underlying mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform receiving data </td></tr>
    <tr><td class="paramname">packet</td><td>A pointer to the received data </td></tr>
    <tr><td class="paramname">packet_size</td><td>the size of the received packet in bytes </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument passed to the data callback creation functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab806b6ea2fbe7dc77fa48faa13ded221" name="ab806b6ea2fbe7dc77fa48faa13ded221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab806b6ea2fbe7dc77fa48faa13ded221">&#9670;&#160;</a></span>waveform_response_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* waveform_response_cb_t) (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, unsigned int code, const char *message, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a response to a waveform command is received. </p>
<p>This is called when a response is received to a command you issued to your waveform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform the command was executed on </td></tr>
    <tr><td class="paramname">code</td><td>The return code of the command. </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument passed to the data callback creation functions. </td></tr>
    <tr><td class="paramname">message</td><td>The text message from the command result. Upon completion of this callback the storage for this string will be freed. If you need it past the context of this callback function you should copy it to storage that you allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac00b936a46820045bed3acebf0957fe8" name="ac00b936a46820045bed3acebf0957fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00b936a46820045bed3acebf0957fe8">&#9670;&#160;</a></span>waveform_state_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* waveform_state_cb_t) (struct <a class="el" href="structwaveform__t.html">waveform_t</a> *waveform, enum <a class="el" href="#ae2459fae8ab0eac5ec65fac9439ac7f0">waveform_state</a> state, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when the waveform state changes. </p>
<p>When the waveform changes state this callback is called to inform the waveform plugin of that fact. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform changing state. </td></tr>
    <tr><td class="paramname">state</td><td>The state to which the waveform is transitioning. </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument passed to waveform_register_activate_cb() or waveform_register_deactivate_cb() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2d99889ade0c2592b685dc30a9da43a9" name="a2d99889ade0c2592b685dc30a9da43a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d99889ade0c2592b685dc30a9da43a9">&#9670;&#160;</a></span>get_class_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t get_class_id </td>
          <td>(</td>
          <td class="paramtype">const struct waveform_vita_packet *</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the class ID from a received packet. </p>
<p>Returns the class ID field from the VITA-49 packet from the radio. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A packet returned from the radio in the waveform_data_cb_t callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer representing the class ID of the packet in host byte order. </dd></dl>

</div>
</div>
<a id="adfa580210dd0ffefbfdcad18d749250c" name="adfa580210dd0ffefbfdcad18d749250c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa580210dd0ffefbfdcad18d749250c">&#9670;&#160;</a></span>get_packet_byte_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * get_packet_byte_data </td>
          <td>(</td>
          <td class="paramtype">const struct waveform_vita_packet *</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data portion of a raw byte data packet. </p>
<p>For a raw data packet returned from the waveform_register_rx_bytes_data_cb or waveform_register_tx_bytes_data_cb registered callbacks, gets the raw data from the radio. The length of this data can be obtained with the <a class="el" href="#a9834d4683d44948974fc305793e2dc13" title="Get the length of the raw byte data of a packet.">get_packet_byte_data_length()</a> call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A packet returned from the radio in the waveform_data_cb_t callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of bytes received in the radio packet </dd></dl>

</div>
</div>
<a id="a9834d4683d44948974fc305793e2dc13" name="a9834d4683d44948974fc305793e2dc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9834d4683d44948974fc305793e2dc13">&#9670;&#160;</a></span>get_packet_byte_data_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_packet_byte_data_length </td>
          <td>(</td>
          <td class="paramtype">const struct waveform_vita_packet *</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of the raw byte data of a packet. </p>
<p>For a raw data packet returned from the waveform_register_rx_bytes_data_cb or waveform_register_tx_bytes_data_cb registered callbacks, gets the length of the raw data from the radio. The data can be obtained with the <a class="el" href="#adfa580210dd0ffefbfdcad18d749250c" title="Get the data portion of a raw byte data packet.">get_packet_byte_data()</a> call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A packet returned from the radio in the waveform_data_cb_t callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned integer representing the number of bytes in the array returned by <a class="el" href="#adfa580210dd0ffefbfdcad18d749250c" title="Get the data portion of a raw byte data packet.">get_packet_byte_data()</a> </dd></dl>

</div>
</div>
<a id="a74454f0bb04541a9aae0d4706908c16e" name="a74454f0bb04541a9aae0d4706908c16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74454f0bb04541a9aae0d4706908c16e">&#9670;&#160;</a></span>get_packet_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t get_packet_count </td>
          <td>(</td>
          <td class="paramtype">const struct waveform_vita_packet *</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current packet count from a received packet. </p>
<p>Gets the current packet count field from the VITA-49 packet. This value is a 4-bit counter that is incremented for every subsequent packet transmitted by a VITA speaker. The specification states that this is a 4-bit value, so the value returned from this function will be increasing between 0x00 and 0x0F, rolling over to 0x00 on an overflow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A packet returned from the radio in the waveform_data_cb_t callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer representing the number of packets received. </dd></dl>

</div>
</div>
<a id="a6773dcf4ec0414dd390ac3f04c04e3a3" name="a6773dcf4ec0414dd390ac3f04c04e3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6773dcf4ec0414dd390ac3f04c04e3a3">&#9670;&#160;</a></span>get_packet_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float * get_packet_data </td>
          <td>(</td>
          <td class="paramtype">const struct waveform_vita_packet *</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the packet data. </p>
<p>Returns an array of floating point values representing either L/R or I/Q pairs depending on the underlying mode. The length of the array returned can be ascertained by calling <a class="el" href="#af58b7edbab25734d6f30fb2b3ded015d" title="Gets the length of a received packet.">get_packet_len()</a>. The data in the returned array will be freed when the callback returns to the library. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A packet returned from the radio in the waveform_data_cb_t callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32-bit floating point values from the radio representing data from the microphone or receiver in host byte order. </dd></dl>

</div>
</div>
<a id="af58b7edbab25734d6f30fb2b3ded015d" name="af58b7edbab25734d6f30fb2b3ded015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58b7edbab25734d6f30fb2b3ded015d">&#9670;&#160;</a></span>get_packet_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t get_packet_len </td>
          <td>(</td>
          <td class="paramtype">const struct waveform_vita_packet *</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a received packet. </p>
<p>Returns the length of the data in a packet received from the radio. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A packet returned from the radio in the waveform_data_cb_t callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the data from the radio in 32-bit words. </dd></dl>

</div>
</div>
<a id="a29c2875ca76cf346551efbb04e6a2029" name="a29c2875ca76cf346551efbb04e6a2029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c2875ca76cf346551efbb04e6a2029">&#9670;&#160;</a></span>get_packet_ts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_packet_ts </td>
          <td>(</td>
          <td class="paramtype">const struct waveform_vita_packet *</td>          <td class="paramname"><span class="paramname"><em>packet</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *</td>          <td class="paramname"><span class="paramname"><em>ts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the timestamp from a received pakcet. </p>
<p>Returns the fractional timestamp from the VITA-49 packet from the radio in a user-provided structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A packet returned from the radio in the waveform_data_cb_t callback. </td></tr>
    <tr><td class="paramname">ts</td><td>A user-provided structure in which to store the timestamp. The user must have allocated memory for this structure and is responsible for freeing it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf05450681f759538b7aec3cea041a5f" name="aaf05450681f759538b7aec3cea041a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf05450681f759538b7aec3cea041a5f">&#9670;&#160;</a></span>get_packet_ts_frac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t get_packet_ts_frac </td>
          <td>(</td>
          <td class="paramtype">const struct waveform_vita_packet *</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the fractional timestamp from a received packet. </p>
<p>Returns the fractional timestamp from the VITA-49 packet from the radio. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A packet returned from the radio in the waveform_data_cb_t callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer representing the fractional timestamp of the packet in host byte order. </dd></dl>

</div>
</div>
<a id="ad4f8cc8b85b17b299531e4430132f57f" name="ad4f8cc8b85b17b299531e4430132f57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f8cc8b85b17b299531e4430132f57f">&#9670;&#160;</a></span>get_packet_ts_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_packet_ts_int </td>
          <td>(</td>
          <td class="paramtype">const struct waveform_vita_packet *</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the integer timestamp from a received packet. </p>
<p>Returns the integral timestamp from the VITA-49 packet from the radio. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A packet returned from the radio in the waveform_data_cb_t callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer representing the integral timestamp of the packet in host byte order. </dd></dl>

</div>
</div>
<a id="ad64bed2653fe8413949e4036ae6d41ff" name="ad64bed2653fe8413949e4036ae6d41ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64bed2653fe8413949e4036ae6d41ff">&#9670;&#160;</a></span>get_stream_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_stream_id </td>
          <td>(</td>
          <td class="paramtype">const struct waveform_vita_packet *</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the stream ID from a received packet. </p>
<p>Returns the stream ID field from the VITA-49 packet from the radio. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A packet returned from the radio in the waveform_data_cb_t callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer representing the stream ID of the packet in host byte order. </dd></dl>

</div>
</div>
<a id="a7e7640dbd52b06d440a74f7d406d2b2b" name="a7e7640dbd52b06d440a74f7d406d2b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7640dbd52b06d440a74f7d406d2b2b">&#9670;&#160;</a></span>waveform_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwaveform__t.html">waveform_t</a> * waveform_create </td>
          <td>(</td>
          <td class="paramtype">struct radio_t *</td>          <td class="paramname"><span class="paramname"><em>radio</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>short_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>underlying_mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>version</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ac1bfb63574043888d9cd0d4156f997ac">waveform_sample_rate</a></td>          <td class="paramname"><span class="paramname"><em>data_sample_rate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a waveform. </p>
<p>Creates a waveform for processing. This will register the waveform with the SDK and set it up to be handled in the event loop when executed. This function can be called more than once if you would like to set up multiple modes in the same waveform program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radio</td><td>A pointer to the radio structure to which you wish to registe this waveform. This is the output of <a class="el" href="#a69cd1dcf1f5d9f48369b5e8a3c5b9c8a" title="Creates a radio definition.">waveform_radio_create()</a> </td></tr>
    <tr><td class="paramname">name</td><td>The full name of the waveform </td></tr>
    <tr><td class="paramname">short_name</td><td>A short name for the waveform. This should be limited to four characters. </td></tr>
    <tr><td class="paramname">underlying_mode</td><td>The "underlying mode" of the waveform. This effects the type of data that you will receive If you would like real audio data, either the LSB or USB modes are appropriate. There will also be a mode named IQ that will give you largely unmolested I/Q samples. This string must be the <em>short</em> name of the underlying mode in the radio. </td></tr>
    <tr><td class="paramname">version</td><td>The version number of your waveform. </td></tr>
    <tr><td class="paramname">data_sample_rate</td><td>The data sample rate to send packets to the radio from the waveform_sample_rate struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated structure representing the waveform. This structure is opaque and you should not attempt to modify it in any way. You are responsible for freeing the structure using <a class="el" href="#a548cfeaa2b9392f547c3d0aa2bcebff7" title="Destroy a waveform.">waveform_destroy()</a> when you are done with it. </dd></dl>

</div>
</div>
<a id="a548cfeaa2b9392f547c3d0aa2bcebff7" name="a548cfeaa2b9392f547c3d0aa2bcebff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548cfeaa2b9392f547c3d0aa2bcebff7">&#9670;&#160;</a></span>waveform_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void waveform_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a waveform. </p>
<p>Destroys a previously allocated waveform freeing all resources it consumes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>A pointer to the waveform structure to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63bf7d6b2413a5699718de606568852e" name="a63bf7d6b2413a5699718de606568852e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bf7d6b2413a5699718de606568852e">&#9670;&#160;</a></span>waveform_discover_radio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sockaddr_in * waveform_discover_radio </td>
          <td>(</td>
          <td class="paramtype">const struct timeval *</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a radio on the network. </p>
<p>Listens to the discovery broadcasts being performed by radios and returns the first one it hears. Returns NULL if a radio can't be found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A timeout value after which the discovery will return unsuccessfully. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the address of the radio. You are responsible for freeing this memory when done. </dd></dl>

</div>
</div>
<a id="aa6f5ca6bc442a603a381eed9d8750e01" name="aa6f5ca6bc442a603a381eed9d8750e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f5ca6bc442a603a381eed9d8750e01">&#9670;&#160;</a></span>waveform_get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * waveform_get_context </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>wf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the waveform context. </p>
<p>This function retrieves the context pointer set by <a class="el" href="#a417c2357020deba99e97a860c9a021a1" title="Sets a structure for waveform context.">waveform_set_context()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wf</td><td>The waveform to set context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The context structure </dd></dl>

</div>
</div>
<a id="a92578b1a0afffc97c43b4b64c785e090" name="a92578b1a0afffc97c43b4b64c785e090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92578b1a0afffc97c43b4b64c785e090">&#9670;&#160;</a></span>waveform_meter_set_float_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_meter_set_float_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of a meter given the name. </p>
<p>This has the same functionality as a waveform_meter_find() followed by a waveform_meter_set_value() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform containing the meter </td></tr>
    <tr><td class="paramname">name</td><td>The name of the meter to set </td></tr>
    <tr><td class="paramname">value</td><td>The value of the meter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the meter name cannot be found in the list, otherwise 0 for success. </dd></dl>

</div>
</div>
<a id="abfc87c7c72f6a7849fe357827bdcfc13" name="abfc87c7c72f6a7849fe357827bdcfc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc87c7c72f6a7849fe357827bdcfc13">&#9670;&#160;</a></span>waveform_meter_set_int_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_meter_set_int_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of a meter given the name. </p>
<p>Sets the meter value given a short. This is a <em>raw</em> function and will set whatever you send it without doing any sanity checking. For advanced usage only. Not recommended for normal use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform containing the meter </td></tr>
    <tr><td class="paramname">name</td><td>The name of the meter to set </td></tr>
    <tr><td class="paramname">value</td><td>The value of the meter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the meter name cannot be found in the list, otherwise 0 for success. </dd></dl>

</div>
</div>
<a id="a53dfbbe31f9eba594d4b91e7d858ef90" name="a53dfbbe31f9eba594d4b91e7d858ef90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53dfbbe31f9eba594d4b91e7d858ef90">&#9670;&#160;</a></span>waveform_meters_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t waveform_meters_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a meter list to the radio. </p>
<p>The meter values in the list will be sent to the radio. Note that this will cause one or more UDP packets to be sent and is therefore not a "cheap" operation. As many meters as possible should be combined into a list and sent simultaneously. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform containing the meter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on an error. Return values are negative values of errno.h. Will return -E2BIG on a short write to the network and -EFBIG if you attempt to send too many meters in a single packet. </dd></dl>

</div>
</div>
<a id="a69cd1dcf1f5d9f48369b5e8a3c5b9c8a" name="a69cd1dcf1f5d9f48369b5e8a3c5b9c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cd1dcf1f5d9f48369b5e8a3c5b9c8a">&#9670;&#160;</a></span>waveform_radio_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct radio_t * waveform_radio_create </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr_in *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a radio definition. </p>
<p>Creates a radio structure. This does not connect to the radio. A radio should be created and have all the configuration done on it before calling <a class="el" href="#a35e070d291054bfac3961ca172d8e77a" title="Start the radio.">waveform_radio_start()</a> to connect and begin operation of the waveform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address of the radio you intend to connect to. There will eventually be a discovery function to be able to find radios out there. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An opaque structure representing the radio. </dd></dl>

</div>
</div>
<a id="a8e3b4c24c78713e599c422575c8681e0" name="a8e3b4c24c78713e599c422575c8681e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3b4c24c78713e599c422575c8681e0">&#9670;&#160;</a></span>waveform_radio_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void waveform_radio_destroy </td>
          <td>(</td>
          <td class="paramtype">struct radio_t *</td>          <td class="paramname"><span class="paramname"><em>radio</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a radio. </p>
<p>Destroys a radio created previously by <a class="el" href="#a69cd1dcf1f5d9f48369b5e8a3c5b9c8a" title="Creates a radio definition.">waveform_radio_create()</a> and frees all associated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radio</td><td>The radio to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35e070d291054bfac3961ca172d8e77a" name="a35e070d291054bfac3961ca172d8e77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e070d291054bfac3961ca172d8e77a">&#9670;&#160;</a></span>waveform_radio_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_radio_start </td>
          <td>(</td>
          <td class="paramtype">struct radio_t *</td>          <td class="paramname"><span class="paramname"><em>radio</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the radio. </p>
<p>Connects to the radio and starts the event loop to begin processing commands. All callbacks should be set up and registered by the time you call this function. Registering a callback while the radio is running will have undefined behavior. This command will immediately return and you must use <a class="el" href="#adbf3e4737aaceab800d7dc193ca5c603" title="Waits for the radio processing to complete.">waveform_radio_wait()</a> to wait for its completion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radio</td><td>The radio on which to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 for failure. </dd></dl>

</div>
</div>
<a id="adbf3e4737aaceab800d7dc193ca5c603" name="adbf3e4737aaceab800d7dc193ca5c603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf3e4737aaceab800d7dc193ca5c603">&#9670;&#160;</a></span>waveform_radio_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_radio_wait </td>
          <td>(</td>
          <td class="paramtype">const struct radio_t *</td>          <td class="paramname"><span class="paramname"><em>radio</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the radio processing to complete. </p>
<p>After your main thread has finished launching the radio with <a class="el" href="#a35e070d291054bfac3961ca172d8e77a" title="Start the radio.">waveform_radio_start()</a>, you will need to wait for completion of your event loop and stop execution of the program. You accomplish this by calling <a class="el" href="#adbf3e4737aaceab800d7dc193ca5c603" title="Waits for the radio processing to complete.">waveform_radio_wait()</a> after starting the radio. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radio</td><td>The radio on which to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 for failure. </dd></dl>

</div>
</div>
<a id="a85463b94e6ff92583bdb5e74e9dfbb2d" name="a85463b94e6ff92583bdb5e74e9dfbb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85463b94e6ff92583bdb5e74e9dfbb2d">&#9670;&#160;</a></span>waveform_register_byte_data_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_register_byte_data_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a81c3b1bbb04e6d6bfe4a904a1d8599f2">waveform_data_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a raw byte data packet callback for a waveform. </p>
<p>Registers a callback that is called when there is a raw byte VITA-49 packet from the radio. This could be data inbound from the radio's serial port or other data producing process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">cb</td><td>The callback function </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument to be passed to the callback on execution. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, -1 on failure </dd></dl>

</div>
</div>
<a id="ad145a05cea374bd25e652b91f31c311c" name="ad145a05cea374bd25e652b91f31c311c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad145a05cea374bd25e652b91f31c311c">&#9670;&#160;</a></span>waveform_register_command_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_register_command_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>command_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a30844370d08fd6482019736b1c7de4cd">waveform_cmd_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a command callback. </p>
<p>Registers a callback is called when a waveform command is requested. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">command_name</td><td>The name of the command for which you would like notification. This is implementation specific to the waveform. If a waveform command is received and there is no callback registered for that command, an error will be returned to the caller. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback function </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument to be passed to the callback on execution. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, -1 on failure </dd></dl>

</div>
</div>
<a id="a614e0ea5956c33b17d1c6b673a8fb12b" name="a614e0ea5956c33b17d1c6b673a8fb12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614e0ea5956c33b17d1c6b673a8fb12b">&#9670;&#160;</a></span>waveform_register_meter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void waveform_register_meter </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>max</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#a1607bb449bae065c8f53b00d9ad5e9af">waveform_units</a></td>          <td class="paramname"><span class="paramname"><em>unit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new meter to a meter list. </p>
<p>Adds a new meter to a meter list and registers it with the radio. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform containing the meter </td></tr>
    <tr><td class="paramname">name</td><td>the name of the meter </td></tr>
    <tr><td class="paramname">min</td><td>The minimum value the meter can take on </td></tr>
    <tr><td class="paramname">max</td><td>The maximum value the meter can take on </td></tr>
    <tr><td class="paramname">unit</td><td>The unit of the meter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success and -1 for failure </dd></dl>

</div>
</div>
<a id="acbada3add642a353a622b3f0e50f5623" name="acbada3add642a353a622b3f0e50f5623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbada3add642a353a622b3f0e50f5623">&#9670;&#160;</a></span>waveform_register_meter_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void waveform_register_meter_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>wf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwaveform__meter__entry.html">waveform_meter_entry</a></td>          <td class="paramname"><span class="paramname"><em>list</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_meters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a set of meters. </p>
<p>Registers an array of meters. This is essentially a loop around waveform_register_meter as a convenience shortcut. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wf</td><td>The waveform on which to register the meter. </td></tr>
    <tr><td class="paramname">list</td><td>The array of meters to register. </td></tr>
    <tr><td class="paramname">num_meters</td><td>The number of meters in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa40d17a9d9365e2586d2a347ec89bb14" name="aa40d17a9d9365e2586d2a347ec89bb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40d17a9d9365e2586d2a347ec89bb14">&#9670;&#160;</a></span>waveform_register_rx_data_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_register_rx_data_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a81c3b1bbb04e6d6bfe4a904a1d8599f2">waveform_data_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a receive data callback for a waveform. </p>
<p>Registers a callback that is called when there is data from the incoming RF data from the receiver. You are expected to do any processing on the data and send appropriate packets back to the radio to be sent out to the audio output devices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">cb</td><td>The callback function </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument to be passed to the callback on execution. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, -1 on failure </dd></dl>

</div>
</div>
<a id="a92cf19d09e17739401827be212740596" name="a92cf19d09e17739401827be212740596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92cf19d09e17739401827be212740596">&#9670;&#160;</a></span>waveform_register_state_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_register_state_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac00b936a46820045bed3acebf0957fe8">waveform_state_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a stauts change callback for a waveform. </p>
<p>When the slice to which the waveform is attached changes state, such as activating or deactivating the waveform, or tx/rx state changes, the callback is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">cb</td><td>The callback function </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument to be passed to the callback upon execution. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon succes, -1 on failure </dd></dl>

</div>
</div>
<a id="a48d28505507751b3710d6fdcb5a844fd" name="a48d28505507751b3710d6fdcb5a844fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d28505507751b3710d6fdcb5a844fd">&#9670;&#160;</a></span>waveform_register_status_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_register_status_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>status_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a30844370d08fd6482019736b1c7de4cd">waveform_cmd_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a status callback. </p>
<p>Registers a callback is called when the radio status changes. This function also handles creating the event subscription in the API. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">status_name</td><td>The name of the subsystem for which you would like to receive status. For example, if you would like to receive slice status updates, set this parameter to "slice". </td></tr>
    <tr><td class="paramname">cb</td><td>The callback function </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument to be passed to the callback on execution. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, -1 on failure </dd></dl>

</div>
</div>
<a id="af8e6660970f108f0c7077fecce516ab9" name="af8e6660970f108f0c7077fecce516ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e6660970f108f0c7077fecce516ab9">&#9670;&#160;</a></span>waveform_register_tx_data_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_register_tx_data_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a81c3b1bbb04e6d6bfe4a904a1d8599f2">waveform_data_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a transmitter data callback for a waveform. </p>
<p>Registers a callback that is called when there is data from the incoming audio source to be transmitted. You are expected to do any processing on the data and send appropriate packets back to the radio to be transmitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">cb</td><td>The callback function </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument to be passed to the callback on execution. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, -1 on failure </dd></dl>

</div>
</div>
<a id="a9b6d1786f6bc57dd7eb37d8f5d0458e2" name="a9b6d1786f6bc57dd7eb37d8f5d0458e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6d1786f6bc57dd7eb37d8f5d0458e2">&#9670;&#160;</a></span>waveform_register_unknown_data_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int waveform_register_unknown_data_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a81c3b1bbb04e6d6bfe4a904a1d8599f2">waveform_data_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a unknown data packet callback for a waveform. </p>
<p>Registers a callback that is called when there is an unknown VITA-49 packet from the radio. This could be anything from a 1PPS packet, to other various packets that we don't handle in other ways. The framework handles RX and TX data callbacks with the above <a class="el" href="#aa40d17a9d9365e2586d2a347ec89bb14" title="Register a receive data callback for a waveform.">waveform_register_rx_data_cb()</a> and <a class="el" href="#af8e6660970f108f0c7077fecce516ab9" title="Register a transmitter data callback for a waveform.">waveform_register_tx_data_cb()</a> but any other VITA-49 packets that are received will cause this callback to be triggered. RX and TX callbacks handle microphone, speaker, transmitter and receiver data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">cb</td><td>The callback function </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument to be passed to the callback on execution. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, -1 on failure </dd></dl>

</div>
</div>
<a id="af39cf0e0b1aa16e00ecf23141a0a231e" name="af39cf0e0b1aa16e00ecf23141a0a231e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39cf0e0b1aa16e00ecf23141a0a231e">&#9670;&#160;</a></span>waveform_send_api_command_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t waveform_send_api_command_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab806b6ea2fbe7dc77fa48faa13ded221">waveform_response_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>command</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a command to the radio and invokes callback. </p>
<p>This version of the command processing waits for a response from the radio and invokes your desired callback. Your callback should be thread-safe as it may not be executed on the same thread as you invoked the command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">cb</td><td>Pointer to a command completion callback function. If this is NULL, no callback will be performed. </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument to be passed to the callback on execution. Can be NULL. </td></tr>
    <tr><td class="paramname">command</td><td>A format string in printf(3) format. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments for format specification </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sequence number on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="a41645619373312c4f6a63059ef724cbc" name="a41645619373312c4f6a63059ef724cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41645619373312c4f6a63059ef724cbc">&#9670;&#160;</a></span>waveform_send_byte_data_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t waveform_send_byte_data_packet </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>data_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a raw byte data packet to the radio. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform sending the data </td></tr>
    <tr><td class="paramname">data</td><td>A reference to an array of bytes to send </td></tr>
    <tr><td class="paramname">data_size</td><td>The number of bytes in the samples array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on an error. Return values are negative values of errno.h and will return -E2BIG on a short write to the network. </dd></dl>

</div>
</div>
<a id="a62ec4ad3e11ef29156d65ad86f50d6ee" name="a62ec4ad3e11ef29156d65ad86f50d6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ec4ad3e11ef29156d65ad86f50d6ee">&#9670;&#160;</a></span>waveform_send_data_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t waveform_send_data_packet </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>samples</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_samples</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#a0d4c553be06c514186a53441a646a371">waveform_packet_type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a data packet to the radio. </p>
<p>After doing any processing necessary in the waveform, you must send back an output packet to the radio representing either audio data to provide to the speaker, or transmit data to supply to the transmitter. This function allows you to queue that data for transmission to the radio. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform sending the data </td></tr>
    <tr><td class="paramname">samples</td><td>An array containing the samples to send. This must be num_samples * sizeof(uint32_t) long. </td></tr>
    <tr><td class="paramname">num_samples</td><td>Samples for the radio. This is either baseband data in L/R format, or complex data in I/Q format depending on the underlying mode. These samples should be in 32-bit float format in host byte order as the library will do any necessary byte swapping for transmission. </td></tr>
    <tr><td class="paramname">type</td><td>The type of packet to send. This is either SPEAKER_DATA for playing on the audio output of the radio or TRANSMITTER_DATA for sending to the RF transmitter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on an error. Return values are negative values of errno.h. Will return -E2BIG on a short write to the network and -EFBIG if you attempt to send too many samples in a single packet. </dd></dl>

</div>
</div>
<a id="a223d94c4c088c85efaba9732fd2ca4dc" name="a223d94c4c088c85efaba9732fd2ca4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223d94c4c088c85efaba9732fd2ca4dc">&#9670;&#160;</a></span>waveform_send_timed_api_command_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t waveform_send_timed_api_command_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *</td>          <td class="paramname"><span class="paramname"><em>at</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab806b6ea2fbe7dc77fa48faa13ded221">waveform_response_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>complete_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab806b6ea2fbe7dc77fa48faa13ded221">waveform_response_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>queued_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>command</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a timed command to the radio and invokes callbacks. </p>
<p>This version of the command processing waits for a response from the radio and invokes your desired callback. It also will optionally call a callback when the command is successfully queued. Your callbacks should be thread-safe as it may not be executed on the same thread as you invoked the command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>Pointer to the waveform structure returned by <a class="el" href="#a7e7640dbd52b06d440a74f7d406d2b2b" title="Create a waveform.">waveform_create()</a> </td></tr>
    <tr><td class="paramname">at</td><td>The time in the future in which to execute the command. </td></tr>
    <tr><td class="paramname">complete_cb</td><td>Pointer to a command completion callback function. If this is NULL, no callback will be performed. </td></tr>
    <tr><td class="paramname">queued_cb</td><td>Pointer to a command queued callback function. If this is NULL, no callback will be performed. </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument to be passed to the callbacks on execution. Can be NULL. </td></tr>
    <tr><td class="paramname">command</td><td>A format string in printf(3) format. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments for format specification </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sequence number on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="a417c2357020deba99e97a860c9a021a1" name="a417c2357020deba99e97a860c9a021a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417c2357020deba99e97a860c9a021a1">&#9670;&#160;</a></span>waveform_set_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void waveform_set_context </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwaveform__t.html">waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>wf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a structure for waveform context. </p>
<p>State is sometimes necessary for a waveform to preserve values. This function allows you to register a pointer to a context structure that will be available during all waveform callbacks. This call is <em>NOT</em> locked by the API so it is incumbent on the user to ensure thread safety of the contents. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wf</td><td>The waveform to set context </td></tr>
    <tr><td class="paramname">ctx</td><td>A pointer to a context structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5020177b871217781f1afe9e0cec790d" name="a5020177b871217781f1afe9e0cec790d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5020177b871217781f1afe9e0cec790d">&#9670;&#160;</a></span>waveform_set_log_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void waveform_set_log_level </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="#af48fc5c972fcaafee3a74e6095e7eac0">waveform_log_levels</a></td>          <td class="paramname"><span class="paramname"><em>level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the log verbosity of the library. </p>
<p>Sets the logging verbosity of the library. Any log messages with a level higher than this setting will be logged to stdout. See the above enum for relative levels of the logs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level of the logging desired </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
